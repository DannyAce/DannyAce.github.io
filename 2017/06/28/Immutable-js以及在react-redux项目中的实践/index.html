<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="本文首发于掘金:https://juejin.im/post/5948985ea0bb9f006bed7472，转载请注明

前言&amp;emsp;&amp;emsp;本文主要介绍facebook推出的一个类库immutable.js，以及如何将immutable.js集成到我们团队现有的react+redux架构的移动端项目中。
本文较长（5000字左右），建议阅读时间： 20 min
通过阅读本文，你可以学习到：
什么是immutable.js,它的出现能解决什么问题
immutable.js的特性以及使用api
在一个redux+react的项目中，引入immutable.js能带来什么提升
如何集成immutable.js到react+redux中
集成前后的数据对比
immutabe.js使用过程中的一些注意点">
    

    <!--Author-->
    
        <meta name="author" content="DannyAce">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Immutable.js以及在react+redux项目中的实践"/>
    

    <!--Open Graph Description-->
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="DannyAce"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

        <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>Immutable.js以及在react+redux项目中的实践 - DannyAce</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css">
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
	
</head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">哈哈哈哈哈</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="https://github.com/DannyAce">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('http://www.codeblocq.com/assets/projects/hexo-theme-clean-blog/img/home-bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Immutable.js以及在react+redux项目中的实践</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                        
                            2017-06-28
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/react/">#react</a> <a href="/tags/redux/">#redux</a> <a href="/tags/immutable/">#immutable</a> <a href="/tags/immutable-js/">#immutable.js</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <blockquote>
<p>本文首发于掘金:<a href="https://juejin.im/post/5948985ea0bb9f006bed7472" target="_blank" rel="external">https://juejin.im/post/5948985ea0bb9f006bed7472</a>，转载请注明</p>
</blockquote>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>&emsp;&emsp;本文主要介绍facebook推出的一个类库immutable.js，以及如何将immutable.js集成到我们团队现有的react+redux架构的移动端项目中。</p>
<p>本文较长（5000字左右），建议阅读时间： <em>20 min</em></p>
<h3 id="通过阅读本文，你可以学习到："><a href="#通过阅读本文，你可以学习到：" class="headerlink" title="通过阅读本文，你可以学习到："></a>通过阅读本文，你可以学习到：</h3><ul>
<li>什么是immutable.js,它的出现能解决什么问题</li>
<li>immutable.js的特性以及使用api</li>
<li>在一个redux+react的项目中，引入immutable.js能带来什么提升</li>
<li>如何集成immutable.js到react+redux中</li>
<li>集成前后的数据对比</li>
<li>immutabe.js使用过程中的一些注意点</li>
</ul>
<a id="more"></a>
<h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><ul>
<li>一. immutable.js<ul>
<li>1.1 原生js引用类型的坑</li>
<li>1.2 immutable.js介绍<ul>
<li>1.2.1 Persistent data structure （持久化数据结构）</li>
<li>1.2.2 structural sharing （结构共享）</li>
<li>1.2.3 support lazy operation  （惰性操作）</li>
</ul>
</li>
<li>1.3 常用api介绍</li>
<li>1.4 immutable.js的优缺点</li>
</ul>
</li>
<li>二. 在react+redux中集成immutable.js实践<ul>
<li>2.1 点餐H5项目引入immutable.js前的现状</li>
<li>2.2 如何将immutableJS集成到一个react+redux项目中<ul>
<li>2.2.1 明确集成方案，边界界定</li>
<li>2.2.2 具体集成代码实现方法</li>
</ul>
</li>
<li>2.3 点餐H5项目优化前后对比</li>
</ul>
</li>
<li>三. immutable.js使用过程中的一些注意点</li>
<li>四. 总结</li>
</ul>
<h1 id="一-immutable-js"><a href="#一-immutable-js" class="headerlink" title="一. immutable.js"></a>一. immutable.js</h1><h2 id="1-1-原生js引用类型的坑"><a href="#1-1-原生js引用类型的坑" class="headerlink" title="1.1 原生js引用类型的坑"></a>1.1 原生js引用类型的坑</h2><p>先考虑如下两个场景：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 场景一</div><div class="line">var obj = &#123;a:1, b:&#123;c:2&#125;&#125;;</div><div class="line">func(obj);</div><div class="line">console.log(obj)  //输出什么？？</div><div class="line">  </div><div class="line">// 场景二</div><div class="line">var obj = =&#123;a:1&#125;;</div><div class="line">var obj2 = obj;</div><div class="line">obj2.a = 2;</div><div class="line">console.log(obj.a);  // 2</div><div class="line">console.log(obj2.a);  // 2</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;上面两个场景相信大家平日里开发过程中非常常见，具体原因相信大家也都知道了，这边不展开细说了，通常这类问题的解决方案是通过浅拷贝或者深拷贝复制一个新对象，从而使得新对象与旧对象引用地址不同。<br>&emsp;&emsp;在js中，引用类型的数据，优点在于频繁的操作数据都是在原对象的基础上修改，不会创建新对象，从而可以有效的利用内存，不会浪费内存，这种特性称为mutable（可变），但恰恰它的优点也是它的缺点，太过于灵活多变在复杂数据的场景下也造成了它的不可控性，假设一个对象在多处用到，在某一处不小心修改了数据，其他地方很难预见到数据是如何改变的，针对这种问题的解决方法，一般就像刚才的例子，会想复制一个新对象，再在新对象上做修改，这无疑会造成更多的性能问题以及内存浪费。<br>&emsp;&emsp;为了解决这种问题，出现了immutable对象，每次修改immutable对象都会创建一个新的不可变对象，而老的对象不会改变。</p>
<h2 id="1-2-immutable-js介绍"><a href="#1-2-immutable-js介绍" class="headerlink" title="1.2 immutable.js介绍"></a>1.2 immutable.js介绍</h2><p>&emsp;&emsp;现今，实现了immutable数据结构的js类库有好多，immutable.js就是其中比较主流的类库之一。</p>
<blockquote>
<p>Immutable.js出自Facebook，是最流行的不可变数据结构的实现之一。它从头开始实现了完全的持久化数据结构，通过使用像tries这样的先进技术来实现结构共享。所有的更新操作都会返回新的值，但是在内部结构是共享的，来减少内存占用(和垃圾回收的失效)。</p>
</blockquote>
<p>immutable.js主要有三大特性：</p>
<ul>
<li>Persistent data structure （持久化数据结构）</li>
<li>structural sharing （结构共享）</li>
<li>support lazy operation  （惰性操作）</li>
</ul>
<p>下面我们来一一具体介绍下这三个特性：</p>
<h3 id="1-2-1-Persistent-data-structure-（持久化数据结构）"><a href="#1-2-1-Persistent-data-structure-（持久化数据结构）" class="headerlink" title="1.2.1 Persistent data structure （持久化数据结构）"></a>1.2.1 Persistent data structure （持久化数据结构）</h3><p>&emsp;&emsp;一般听到持久化，在编程中第一反应应该是，数据存在某个地方，需要用到的时候就能从这个地方拿出来直接使用<br>&emsp;&emsp;但这里说的持久化是另一个意思，用来描述一种数据结构，一般函数式编程中非常常见，指一个数据，在被修改时，仍然能够保持修改前的状态，从本质来说，这种数据类型就是不可变类型，也就是immutable<br>&emsp;&emsp;immutable.js提供了十余种不可变的类型（List，Map，Set，Seq，Collection，Range等）<br>&emsp;&emsp;到这，有些同学可能会觉得，这和之前讲的拷贝有什么区别，也是每次都创建一个新对象，开销一样很大。ok，那接下来第二个特性会为你揭开疑惑。</p>
<h3 id="1-2-2-structural-sharing-（结构共享）"><a href="#1-2-2-structural-sharing-（结构共享）" class="headerlink" title="1.2.2 structural sharing （结构共享）"></a>1.2.2 structural sharing （结构共享）</h3><p><img src="https://dn-mhke0kuv.qbox.me/3a7a2cd51b6fb6850e00.gif" alt="">(图片来自网络)</p>
<blockquote>
<p>immutable使用先进的tries(字典树)技术实现结构共享来解决性能问题，当我们对一个Immutable对象进行操作的时候，ImmutableJS会只clone该节点以及它的祖先节点，其他保持不变，这样可以共享相同的部分，大大提高性能。</p>
</blockquote>
<p><strong>这边岔开介绍一下tries（字典树），我们来看一个例子</strong><br><img src="https://dn-mhke0kuv.qbox.me/203eee65192ccb61d3d3.jpg" alt=""><br><img src="https://dn-mhke0kuv.qbox.me/c07ad7d742c234e1f342.jpg" alt=""><br><img src="https://dn-mhke0kuv.qbox.me/7c108cc86cd6b65ce38e.jpg" alt=""><br>(图片来自网络)<br>&emsp;&emsp;图1就是一个字典树结构object对象，顶端是root节点，每个子节点都有一个唯一标示（在immutable.js中就是hashcode）<br>&emsp;&emsp;假设我们现在取data.in的值，根据标记i和n的路径.可以找到包含5的节点.，可知data.in=5, 完全不需要遍历整个对象<br>&emsp;&emsp;那么，现在我们要把data.tea从3修改成14，怎么做呢？<br>&emsp;&emsp;可以看到图2绿色部分，不需要去遍历整棵树，只要从root开始找就行<br>&emsp;&emsp;实际使用时，可以创建一个新的引用，如图3，data.tea建一个新的节点，其他节点和老的对象共享，而老的对象还是保持不变<br>&emsp;&emsp;由于这个特性，比较两个对象时，只要他们的hashcode是相同的，他们的值就是一样的，这样可以避免深度遍历</p>
<h3 id="1-2-3-support-lazy-operation-（惰性操作）"><a href="#1-2-3-support-lazy-operation-（惰性操作）" class="headerlink" title="1.2.3 support lazy operation  （惰性操作）"></a>1.2.3 support lazy operation  （惰性操作）</h3><ul>
<li>惰性操作 Seq</li>
<li>特征1：Immutable (不可变)</li>
<li>特征2：lazy（惰性，延迟）</li>
</ul>
<p>这个特性非常的有趣，这里的lazy指的是什么？很难用语言来描述，我们看一个demo，看完你就明白了<br><img src="https://dn-mhke0kuv.qbox.me/f048f20e035056014dfb.png" alt=""><br>&emsp;&emsp;这段代码的意思就是，数组先取奇数，然后再对基数进行平方操作，然后在console.log第2个数，同样的代码，用immutable的seq对象来实现，filter只执行了3次，但原生执行了8次。<br>&emsp;&emsp;其实原理就是，用seq创建的对象，其实代码块没有被执行，只是被声明了，代码在get(1)的时候才会实际被执行，取到index=1的数之后，后面的就不会再执行了，所以在filter时，第三次就取到了要的数，从4-8都不会再执行<br>&emsp;&emsp;想想，如果在实际业务中，数据量非常大，如在我们点餐业务中，商户的菜单列表可能有几百道菜，一个array的长度是几百，要操作这样一个array，如果应用惰性操作的特性，会节省非常多的性能</p>
<h2 id="1-3-常用api介绍"><a href="#1-3-常用api介绍" class="headerlink" title="1.3 常用api介绍"></a>1.3 常用api介绍</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">//Map()  原生object转Map对象 (只会转换第一层，注意和fromJS区别)</div><div class="line">immutable.Map(&#123;name:&apos;danny&apos;, age:18&#125;)</div><div class="line">  </div><div class="line">//List()  原生array转List对象 (只会转换第一层，注意和fromJS区别)</div><div class="line">immutable.List([1,2,3,4,5])</div><div class="line"> </div><div class="line">//fromJS()   原生js转immutable对象  (深度转换，会将内部嵌套的对象和数组全部转成immutable)</div><div class="line">immutable.fromJS([1,2,3,4,5])    //将原生array  --&gt; List</div><div class="line">immutable.fromJS(&#123;name:&apos;danny&apos;, age:18&#125;)   //将原生object  --&gt; Map</div><div class="line">  </div><div class="line">//toJS()  immutable对象转原生js  (深度转换，会将内部嵌套的Map和List全部转换成原生js)</div><div class="line">immutableData.toJS();</div><div class="line">  </div><div class="line">//查看List或者map大小  </div><div class="line">immutableData.size  或者 immutableData.count()</div><div class="line">  </div><div class="line">// is()   判断两个immutable对象是否相等</div><div class="line">immutable.is(imA, imB);</div><div class="line">  </div><div class="line">//merge()  对象合并</div><div class="line">var imA = immutable.fromJS(&#123;a:1,b:2&#125;);</div><div class="line">var imA = immutable.fromJS(&#123;c:3&#125;);</div><div class="line">var imC = imA.merge(imB);</div><div class="line">console.log(imC.toJS())  //&#123;a:1,b:2,c:3&#125;</div><div class="line">  </div><div class="line">//增删改查（所有操作都会返回新的值，不会修改原来值）</div><div class="line">var immutableData = immutable.fromJS(&#123;</div><div class="line">    a:1,</div><div class="line">    b:2，</div><div class="line">    c:&#123;</div><div class="line">        d:3</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line">var data1 = immutableData.get(&apos;a&apos;) //  data1 = 1  </div><div class="line">var data2 = immutableData.getIn([&apos;c&apos;, &apos;d&apos;]) // data2 = 3   getIn用于深层结构访问</div><div class="line">var data3 = immutableData.set(&apos;a&apos; , 2);   // data3中的 a = 2</div><div class="line">var data4 = immutableData.setIn([&apos;c&apos;, &apos;d&apos;], 4);   //data4中的 d = 4</div><div class="line">var data5 = immutableData.update(&apos;a&apos;,function(x)&#123;return x+4&#125;)   //data5中的 a = 5</div><div class="line">var data6 = immutableData.updateIn([&apos;c&apos;, &apos;d&apos;],function(x)&#123;return x+4&#125;)   //data6中的 d = 7</div><div class="line">var data7 = immutableData.delete(&apos;a&apos;)   //data7中的 a 不存在</div><div class="line">var data8 = immutableData.deleteIn([&apos;c&apos;, &apos;d&apos;])   //data8中的 d 不存在</div></pre></td></tr></table></figure>
<p>上面只列举了部分常用方法，具体查阅<strong>官网api:<a href="http://facebook.github.io/immutable-js/docs/#/" target="_blank" rel="external">http://facebook.github.io/immutable-js/docs/#/</a></strong><br>immutablejs还有很多类似underscore语法糖，使用immutable.js之后完全可以在项目中去除lodash或者underscore之类的工具库。</p>
<h2 id="1-4-immutable-js的优缺点"><a href="#1-4-immutable-js的优缺点" class="headerlink" title="1.4 immutable.js的优缺点"></a>1.4 immutable.js的优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li>降低mutable带来的复杂度</li>
<li>节省内存</li>
<li>历史追溯性（时间旅行）：时间旅行指的是，每时每刻的值都被保留了，想回退到哪一步只要简单的将数据取出就行，想一下如果现在页面有个撤销的操作，撤销前的数据被保留了，只需要取出就行，这个特性在redux或者flux中特别有用</li>
<li>拥抱函数式编程：immutable本来就是函数式编程的概念，纯函数式编程的特点就是，只要输入一致，输出必然一致，相比于面向对象，这样开发组件和调试更方便</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>需要重新学习api</li>
<li>资源包大小增加（源码5000行左右）</li>
<li>容易与原生对象混淆：由于api与原生不同，混用的话容易出错。</li>
</ul>
<h1 id="二-在react-redux中集成immutable-js实践"><a href="#二-在react-redux中集成immutable-js实践" class="headerlink" title="二. 在react+redux中集成immutable.js实践"></a>二. 在react+redux中集成immutable.js实践</h1><p>&emsp;&emsp;前面介绍了这么多，其实是想引出这块重点，这章节会<strong>结合点评点餐团队在实际项目中的实践，给出使用immutable.js前后对react+redux项目的性能提升</strong></p>
<h2 id="2-1-点餐H5项目引入immutable-js前的现状"><a href="#2-1-点餐H5项目引入immutable-js前的现状" class="headerlink" title="2.1 点餐H5项目引入immutable.js前的现状"></a>2.1 点餐H5项目引入immutable.js前的现状</h2><p>&emsp;&emsp;目前项目使用react+redux，由于项目的不断迭代以及需求复杂度的提高，redux中维护的state结构日渐庞大，已经不是一个简单的平铺数据了，如菜单页state已经会出现三四层的object以及array嵌套，我们知道，JS中的object与array是引用类型，在不断的操作过程中，state经过多次的action改变之后， 原本复杂state已经变得不可控，结果就是导致了一次state变化牵动了许多自身状态没有发生改动的component去re-render。如下图<br><img src="https://dn-mhke0kuv.qbox.me/0cd51739fc8dc98b4986.png" alt=""><br>&emsp;&emsp;这里推荐一下react的性能指标工具react-addons-perf<br>&emsp;&emsp;如果你没有使用这个工具看之前，别人问你，图中这个简单的堂食/外带的button的变化会引起哪些component去re-render，你可能会回答只有就餐方式这个component。<br>&emsp;&emsp;但当你真正使用react-addons-perf去查看之后你会发现，WTF？？！一次操作竟然导致了这么多没任何关系的component重新渲染了？？<br>&emsp;&emsp;<strong>什么原因？？</strong></p>
<h4 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">shouldComponentUpdate (nextProps, nextState) &#123;</div><div class="line">   return nextProps.id !== this.props.id;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;相信接触过react开发的同学都知道，react有个重要的性能优化的点就是shouldComponentUpdate，shouldComponentUpdate返回true代码该组件要re-render，false则不重新渲染<br>&emsp;&emsp;那简单的场景可以直接使用==去判断this.props和nextProps是否相等，但当props是一个复杂的结构时，==肯定是没用的<br>&emsp;&emsp;网上随便查一下就会发现shallowCompare这个东西，我们来试一下<br><strong>使用shallowCompare的例子：</strong><br><img src="https://dn-mhke0kuv.qbox.me/6ac16c0725646004ba1c.png" alt=""><br>可以看到，其实2个对象的count是不相等的，但shallowCompare返回的还是true<br><strong>原因：</strong><br>&emsp;&emsp;shallowCompare只是进行了对象的顶层节点比较，也就是浅比较，上图中的props由于结构比较复杂，在深层的对象中有count不一样，所以这种情况无法通过shallowCompare处理。<br><strong>shallowEqual源码：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">function shallowEqual(objA, objB) &#123;</div><div class="line">  if (is(objA, objB)) &#123;</div><div class="line">    return true;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  if (typeof objA !== &apos;object&apos; || objA === null || typeof objB !== &apos;object&apos; || objB === null) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  var keysA = Object.keys(objA);</div><div class="line">  var keysB = Object.keys(objB);</div><div class="line">  </div><div class="line">  if (keysA.length !== keysB.length) &#123;</div><div class="line">    return false;</div><div class="line">  &#125;</div><div class="line">//这里只比较了对象A和B第一层是否相等，当对象过深时，无法返回正确结果</div><div class="line">  // Test for A&apos;s keys different from B.</div><div class="line">  for (var i = 0; i &lt; keysA.length; i++) &#123;</div><div class="line">    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) &#123;</div><div class="line">      return false;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  return true;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>&emsp;&emsp;这里，我们肯定不可能每次比较都是用深比较，去遍历所有的结构，这样带来的性能代价是巨大的，刚才我们说到immutable.js有个特性是引用比较（hashcode），这个特性就完美契合这边的场景</strong></p>
<h2 id="2-2-如何将immutableJS集成到一个react-redux项目中"><a href="#2-2-如何将immutableJS集成到一个react-redux项目中" class="headerlink" title="2.2 如何将immutableJS集成到一个react+redux项目中"></a>2.2 如何将immutableJS集成到一个react+redux项目中</h2><h3 id="2-2-1-明确集成方案，边界界定"><a href="#2-2-1-明确集成方案，边界界定" class="headerlink" title="2.2.1 明确集成方案，边界界定"></a>2.2.1 明确集成方案，边界界定</h3><p>&emsp;&emsp;首先，我们有必要来划分一下边界，哪些数据需要使用不可变数据，哪些数据要使用原生js数据结构，哪些地方需要做互相转换</p>
<ul>
<li>在redux中，全局state必须是immutable的，这点毋庸置疑是我们使用immutable来优化redux的核心</li>
<li>组件props是通过redux的connect从state中获得的，并且引入immutableJS的另一个目的是减少组件shouldComponentUpdate中不必要渲染，shouldComponentUpdate中比对的是props，如果props是原生JS就失去了优化的意义</li>
<li>组件内部state如果需要提交到store的，必须是immutable，否则不强制</li>
<li>view提交到action中的数据必须是immutable</li>
<li>Action提交到reducer中的数据必须是immutable</li>
<li>reducer中最终处理state必须是以immutable的形式处理并返回</li>
<li>与服务端ajax交互中返回的callback统一封装，第一时间转换成immutable数据</li>
</ul>
<p>&emsp;&emsp;从上面这些点可以看出，几乎整个项目都是必须使用immutable的，只有在少数与外部依赖有交互的地方使用了原生js。<br>&emsp;&emsp;这么做的目的其实就是为了防止在大型项目中，原生js与immutable混用，导致coder自己都不清楚一个变量中存储的到底是什么类型的数据。<br>&emsp;&emsp;那有人可能会觉得说，在一个全新项目中这样是可行的，但在一个已有的成熟项目中，要将所有的变量全部改成immutablejs，代码的改动量与侵入性非常大，风险也高。那他们会想到，将reducer中的state用fromJS()改成immutable进行state操作，然后再通过toJS()转成原生js返回出来，这样不就可以即让state变得可追溯，又不用去修改reducer以外的代码，代价非常的小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">export default function indexReducer(state, action) &#123;</div><div class="line">    switch (action.type) &#123;</div><div class="line">    case RECEIVE_MENU:</div><div class="line">        state = immutable.fromJS(state);   //转成immutable</div><div class="line">        state = state.merge(&#123;a:1&#125;);</div><div class="line">        return state.toJS()    //转回原生js</div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>两点问题：</strong></p>
<ol>
<li>fromJS() 和 toJS() 是深层的互转immutable对象和原生对象，性能开销大，尽量不要使用（见下一章节做了具体的对比）</li>
<li>组件中props和state还是原生js，shouldComponentUpdate仍然无法做利用immutablejs的优势做深度比较</li>
</ol>
<h3 id="2-2-2-具体集成代码实现方法"><a href="#2-2-2-具体集成代码实现方法" class="headerlink" title="2.2.2 具体集成代码实现方法"></a>2.2.2 具体集成代码实现方法</h3><h4 id="redux-immutable"><a href="#redux-immutable" class="headerlink" title="redux-immutable"></a>redux-immutable</h4><p>&emsp;&emsp;redux中，第一步肯定利用combineReducers来合并reducer并初始化state，redux自带的combineReducers只支持state是原生js形式的，所以这里我们需要使用redux-immutable提供的combineReducers来替换原来的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">import &#123;combineReducers&#125; from &apos;redux-immutable&apos;;</div><div class="line">import dish from &apos;./dish&apos;;</div><div class="line">import menu from &apos;./menu&apos;;</div><div class="line">import cart from &apos;./cart&apos;;</div><div class="line"> </div><div class="line">const rootReducer = combineReducers(&#123;</div><div class="line">    dish,</div><div class="line">    menu,</div><div class="line">    cart,</div><div class="line">&#125;);</div><div class="line"> </div><div class="line">export default rootReducer;</div></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;reducer中的initialState肯定也需要初始化成immutable类型</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const initialState = Immutable.Map(&#123;&#125;);</div><div class="line">export default function menu(state = initialState, action) &#123;</div><div class="line">    switch (action.type) &#123;</div><div class="line">    case SET_ERROR:</div><div class="line">        return state.set(&apos;isError&apos;, true);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;state成为了immutable类型，那相应的页面其他文件都需要做相应的写法改变</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//connect</div><div class="line">function mapStateToProps(state) &#123;</div><div class="line">    return &#123;</div><div class="line">        menuList: state.getIn([&apos;dish&apos;, &apos;list&apos;]),  //使用get或者getIn来获取state中的变量</div><div class="line">        CartList: state.getIn([&apos;dish&apos;, &apos;cartList&apos;])</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;页面中原来的原生js变量需要改造成immutable类型，不一一列举了</p>
<h4 id="服务端交互ajax封装"><a href="#服务端交互ajax封装" class="headerlink" title="服务端交互ajax封装"></a>服务端交互ajax封装</h4><p>&emsp;&emsp;前端代码使用了immutable，但服务端下发的数据还是json，所以需要统一在ajax处做封装并且将服务端返回数据转成immutable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">//伪代码</div><div class="line">$.ajax(&#123;</div><div class="line">    type: &apos;get&apos;,</div><div class="line">    url: &apos;XXX&apos;,</div><div class="line">    dataType: &apos;json&apos;,</div><div class="line">    success(res)&#123;</div><div class="line">        res = immutable.fromJS(res || &#123;&#125;);</div><div class="line">        callback &amp;&amp; callback(res);</div><div class="line">    &#125;,</div><div class="line">    error(e) &#123;</div><div class="line">        e = immutable.fromJS(e || &#123;&#125;);</div><div class="line">        callback &amp;&amp; callback(e);</div><div class="line">    &#125;,</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这样的话，页面中统一将ajax返回当做immutable类型来处理，不用担心混淆</p>
<h4 id="shouldComponentUpdate-1"><a href="#shouldComponentUpdate-1" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h4><p>&emsp;&emsp;<strong>重中之重！</strong>之前已经介绍了很多为什么要用immutable来改造shouldComponentUpdate，这里就不多说了，直接看怎么改造<br>shouldComponentUpdate具体怎么封装有很多种办法，我们这里选择了封装一层component的基类，在基类中去统一处理shouldComponentUpdate，组件中直接继承基类的方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">//baseComponent.js   component的基类方法</div><div class="line">  </div><div class="line">import React from &apos;react&apos;;</div><div class="line">import &#123;is&#125; from &apos;immutable&apos;;</div><div class="line"> </div><div class="line">class BaseComponent extends React.Component &#123;</div><div class="line">    constructor(props, context, updater) &#123;</div><div class="line">        super(props, context, updater);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">    shouldComponentUpdate(nextProps, nextState) &#123;</div><div class="line">        const thisProps = this.props || &#123;&#125;;</div><div class="line">        const thisState = this.state || &#123;&#125;;</div><div class="line">        nextState = nextState || &#123;&#125;;</div><div class="line">        nextProps = nextProps || &#123;&#125;;</div><div class="line"> </div><div class="line">        if (Object.keys(thisProps).length !== Object.keys(nextProps).length ||</div><div class="line">            Object.keys(thisState).length !== Object.keys(nextState).length) &#123;</div><div class="line">            return true;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        for (const key in nextProps) &#123;</div><div class="line">            if (!is(thisProps[key], nextProps[key])) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        for (const key in nextState) &#123;</div><div class="line">            if (!is(thisState[key], nextState[key])) &#123;</div><div class="line">                return true;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">export default BaseComponent;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;组件中如果需要使用统一封装的shouldComponentUpdate，则直接继承基类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">import BaseComponent from &apos;./BaseComponent&apos;;</div><div class="line">class Menu extends BaseComponent &#123;</div><div class="line">    constructor() &#123;</div><div class="line">        super();</div><div class="line">    &#125;</div><div class="line">    …………</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&emsp;&emsp;当然如果组件不想使用封装的方法，那直接在该组件中重写shouldComponentUpdate就行了</p>
<h3 id="2-3-点餐H5项目优化前后对比"><a href="#2-3-点餐H5项目优化前后对比" class="headerlink" title="2.3 点餐H5项目优化前后对比"></a>2.3 点餐H5项目优化前后对比</h3><p>这边只是截了几张图举例<br>优化前搜索页：<br><img src="https://dn-mhke0kuv.qbox.me/4e6d781925205a133772.png" alt=""><br>优化后：<br><img src="https://dn-mhke0kuv.qbox.me/16ca50a5805d820d5aca.png" alt=""><br>优化前购物车页：<br><img src="https://dn-mhke0kuv.qbox.me/1752f5c1932895e84d73.png" alt=""><br>优化后：<br><img src="https://dn-mhke0kuv.qbox.me/cfc07faa4104132c8a6f.png" alt=""></p>
<h1 id="三-immutable-js使用过程中的一些注意点"><a href="#三-immutable-js使用过程中的一些注意点" class="headerlink" title="三. immutable.js使用过程中的一些注意点"></a>三. immutable.js使用过程中的一些注意点</h1><h4 id="1-fromJS和toJS会深度转换数据，随之带来的开销较大，尽可能避免使用，单层数据转换使用Map-和List"><a href="#1-fromJS和toJS会深度转换数据，随之带来的开销较大，尽可能避免使用，单层数据转换使用Map-和List" class="headerlink" title="1.fromJS和toJS会深度转换数据，随之带来的开销较大，尽可能避免使用，单层数据转换使用Map()和List()"></a>1.fromJS和toJS会深度转换数据，随之带来的开销较大，尽可能避免使用，单层数据转换使用Map()和List()</h4><p>（做了个简单的fromJS和Map性能对比，同等条件下，分别用两种方法处理1000000条数据，可以看到fromJS开销是Map的4倍）<br><img src="https://dn-mhke0kuv.qbox.me/46508e7fe01297e57b31.png" alt=""></p>
<h4 id="2-js是弱类型，但Map类型的key必须是string！-看下图官网说明"><a href="#2-js是弱类型，但Map类型的key必须是string！-看下图官网说明" class="headerlink" title="2.js是弱类型，但Map类型的key必须是string！(看下图官网说明)"></a>2.js是弱类型，但Map类型的key必须是string！(看下图官网说明)</h4><p><img src="https://dn-mhke0kuv.qbox.me/2d90e7d01818f9793e6b.png" alt=""></p>
<h4 id="3-所有针对immutable变量的增删改必须左边有赋值，因为所有操作都不会改变原来的值，只是生成一个新的变量"><a href="#3-所有针对immutable变量的增删改必须左边有赋值，因为所有操作都不会改变原来的值，只是生成一个新的变量" class="headerlink" title="3.所有针对immutable变量的增删改必须左边有赋值，因为所有操作都不会改变原来的值，只是生成一个新的变量"></a>3.所有针对immutable变量的增删改必须左边有赋值，因为所有操作都不会改变原来的值，只是生成一个新的变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">//javascript</div><div class="line">var arr = [1,2,3,4];</div><div class="line">arr.push(5);</div><div class="line">console.log(arr) //[1,2,3,4,5]</div><div class="line">  </div><div class="line">//immutable</div><div class="line">var arr = immutable.fromJS([1,2,3,4])</div><div class="line">//错误用法</div><div class="line">arr.push(5);</div><div class="line">console.log(arr) //[1,2,3,4]</div><div class="line">//正确用法</div><div class="line">arr = arr.push(5);</div><div class="line">console.log(arr) //[1,2,3,4,5]</div></pre></td></tr></table></figure>
<h4 id="4-引入immutablejs后，不应该再出现对象数组拷贝的代码-如下举例"><a href="#4-引入immutablejs后，不应该再出现对象数组拷贝的代码-如下举例" class="headerlink" title="4.引入immutablejs后，不应该再出现对象数组拷贝的代码(如下举例)"></a>4.引入immutablejs后，不应该再出现对象数组拷贝的代码(如下举例)</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//es6对象复制</div><div class="line">var state = Object.assign(&#123;&#125;, state, &#123;</div><div class="line">    key: value</div><div class="line">&#125;);</div><div class="line">  </div><div class="line">//array复制</div><div class="line">var newArr = [].concat([1,2,3])</div></pre></td></tr></table></figure>
<h4 id="5-获取深层深套对象的值时不需要做每一层级的判空"><a href="#5-获取深层深套对象的值时不需要做每一层级的判空" class="headerlink" title="5. 获取深层深套对象的值时不需要做每一层级的判空"></a>5. 获取深层深套对象的值时不需要做每一层级的判空</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//javascript</div><div class="line">var obj = &#123;a:1&#125;</div><div class="line">var res = obj.a.b.c   //error</div><div class="line">  </div><div class="line">//immutable</div><div class="line">var immutableData=immutable.fromJS(&#123;a:1&#125;)</div><div class="line">var res = immutableData.getIn([&apos;a&apos;, &apos;b&apos;, &apos;c&apos;])  //undefined</div></pre></td></tr></table></figure>
<h4 id="6-immutable对象直接可以转JSON-stringify-不需要显式手动调用toJS-转原生"><a href="#6-immutable对象直接可以转JSON-stringify-不需要显式手动调用toJS-转原生" class="headerlink" title="6.immutable对象直接可以转JSON.stringify(),不需要显式手动调用toJS()转原生"></a>6.immutable对象直接可以转JSON.stringify(),不需要显式手动调用toJS()转原生</h4><h4 id="7-判断对象是否是空可以直接用size"><a href="#7-判断对象是否是空可以直接用size" class="headerlink" title="7. 判断对象是否是空可以直接用size"></a>7. 判断对象是否是空可以直接用size</h4><h4 id="8-调试过程中要看一个immutable变量中真实的值，可以chrome中加断点，在console中使用-toJS-方法来查看"><a href="#8-调试过程中要看一个immutable变量中真实的值，可以chrome中加断点，在console中使用-toJS-方法来查看" class="headerlink" title="8.调试过程中要看一个immutable变量中真实的值，可以chrome中加断点，在console中使用.toJS()方法来查看"></a>8.调试过程中要看一个immutable变量中真实的值，可以chrome中加断点，在console中使用.toJS()方法来查看</h4><h1 id="四-总结"><a href="#四-总结" class="headerlink" title="四. 总结"></a>四. 总结</h1><p>&emsp;&emsp;总的来说immutable.js的出现解决了许多原生js的痛点，并且自身对性能方面做了许多的优化处理，而且immuable.js作为和react同期推出的一个产品，完美的契合了react+redux的state流处理，redux的宗旨就是单一数据流，可追溯，这两点恰恰是immutable.js的优势，自然水到渠成，何乐而不为。<br>&emsp;&emsp;当然也不是所有使用react+redux的场景都需要使用immutable.js，建议满足项目足够大，state结构足够复杂的原则，小项目可以手动处理shouldComponentUpdate，不建议使用，得不偿失。</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/DannyAce" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2017 DannyAce<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>